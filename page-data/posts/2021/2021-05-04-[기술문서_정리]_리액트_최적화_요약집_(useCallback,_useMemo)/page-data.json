{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/posts/2021/2021-05-04-[기술문서_정리]_리액트_최적화_요약집_(useCallback,_useMemo)/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>기술 문서 읽기 챌린지 [2021년 5월 4일]</h1>\n<h2><strong>리액트 최적화 요약집 (useCallback, useMemo …)</strong></h2>\n<p><strong>1. 리액트 최적화란 무슨 뜻일까?</strong></p>\n<ul>\n<li>최적화란 프로그램 변현 기술로 코드를 이용하여 CPU, 메모리의 리소스가 적게 소모시키며 속도도 향상해주도록 하는 것</li>\n<li>리액트 최적화는 리액트 기술을 활용하여 관련 코드를 이용한 성능 개선을 시켜준다고 볼 수 있다.</li>\n</ul>\n<p><strong>2. 데이터를 업데이트 하는 과정에서 불변성을 지켜야 되는데 그 이유는?</strong></p>\n<ul>\n<li>자식 컴포넌트에 부모 컴포넌트에서 해당 데이터가 생기거나 할 경우 자식 컴포넌트까지 렌더링이 된다\n<ul>\n<li>이런 상황은 Virtual DOM에만 리렌더링을 해주어 큰 문제가 일어나지 않는다.<br>\n하지만 최악의 조건인 상황이나 관련 데이터들이 한 번에 수백 개씩 혹은 그 이상이라면 성능 손실이 발생하며<br>\n이는 렌더링에서 수행하는 로직이 많을수록, 많은 컴포넌트를 출력할수록 손실을 커질 것임.</li>\n</ul>\n</li>\n</ul>\n<p><strong>3. 리액트에서는 렌더링이 되는 대표적인 조건</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. state 변경이 있을 때\n2. 부모 컴포넌트가 렌더링 될 때\n3. 새로운 props이 들어올 때\n4. shouldComponentUpdate에서 true가 반환될 때\n5. forceUpdate가 실행될 때</code></pre></div>\n<ul>\n<li>여기서 1번과 2번은 얕은 비교를 통해 새로운 값인지 여부를 따져 리렌더링을 한다</li>\n<li>클래스 컴포넌트에서는 렌더링이 될 경우, render 메서드만 리 렌더링이 되지만,<br>\n함수형 컴포넌트(hooks)에서는 위 조건 중에 하나라도 될 경우 함수 전체가 재실행</li>\n</ul>\n<p><strong>4. 위 문제를 해결할 수 있는 <code class=\"language-text\">useMemo</code>와 <code class=\"language-text\">useCallback</code></strong></p>\n<ul>\n<li>\n<p><strong><code class=\"language-text\">useMemo</code></strong></p>\n<ul>\n<li>복잡한 함수 결괏값을 기억 (함수의 리턴값을 기억)\n<ul>\n<li><code class=\"language-text\">useRef</code>는 일반 값을 기억</li>\n</ul>\n</li>\n<li><strong>사용하는 이유</strong><br>\nuseCallback 사용만으로는 하위 컴포넌트의 리렌더를 막을 수 없음<br>\n하위 컴포넌트가 참조 동일성에, 의존적인, 최적화된 Purecomponent 이어야만<br>\n비로소 불필요한 리 렌더링을 막을 모든 것이 완성됨.</li>\n<li><strong>사용법</strong>\n<ul>\n<li>고차 컴포넌트이므로 사용 중인 component를 memo로 감싸주기만 하면 됨.</li>\n<li>props에 대해 기본으로 제공되는 얕은 비교가 아닌 커스텀을 하고 싶다면<br>\n두 번째 인자로 비교 함수를 넣어 사용할 수 있음</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">useMemo</code>는 메모리제이션된 <strong>값</strong>을 반환한다 <em>(리액트 공식 문서)</em></p>\n</blockquote>\n</li>\n<li>\n<p><strong><code class=\"language-text\">useCallback</code></strong></p>\n<ul>\n<li>함수 자체를 기억하고 있음</li>\n<li>의존성에 포함된 값이 변경되지 않는다면 이전에 생성한 함수 참조 값을 반환해줌</li>\n<li><strong>사용하는 이유</strong><br>\n현재 하위 컴포넌트에 전달하는 콜백 함수를 inline 함수로 사용하고 있다거나,<br>\n컴포넌트 내에서 함수를 생성하고 있다면 (프로그래밍 구동에는 문제가 없겠지만)<br>\n<strong>새로운 함수 참조 값을 계속해서 만들고 있는 것!!!</strong></li>\n<li><strong>사용법</strong>\n<ul>\n<li>인라인 콜백과 그것의 의존성 값의 배열을 전달<br>\nuseCallback은 콜백의 메모이제이션된 버전을 반환할 것임.<br>\n그 메모이제이션된 버전은 콜백의 의존성이 변경되었을 때에만 변경됨.</li>\n<li>자식컴포넌트에 함수를 넘길 때 무조건 useCallback를 적용시켜줘야 한다.<br>\n<em>자식 입장에서는 부모가 매번 새로운 함수를 주는 것이라고 판단한다</em> 고 한다.</li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">useCallback</code>의 동작방식</strong>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect에서 제2의 인자로 의존성 배열 안에 값이 존재할 경우\n    => componentDidUpdate\nuseEffect에서 제2의 인자로 의존성 배열로 빈 배열로 존재할 경우\n    => componentDidMount</code></pre></div>\n<ul>\n<li><code class=\"language-text\">useEffect</code>와 동작방식이 유사함!</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">useCallback</code>는 메모리제이션된 <strong>함수</strong>를 반환한다 <em>(리액트 공식 문서)</em></p>\n</blockquote>\n</li>\n<li>\n<p>주의해야할 점</p>\n<ul>\n<li>함수 생성자체가 비용이 클 경우, 클릭 이벤트처럼 여러 번 누를 경우에<br>\n<em>기억을 잘해서 처음 찍혔단 값을 계속 가지고 있는다</em>.<br>\n그래서 두번째 인자에 배열 안으로 같이 넣어줘야. (useEffect와 유사 방식)</li>\n<li>useMemo, useCallback, useEffect가 <strong>2번째 인자가 중요</strong>하다<br>\n(어느 시점에 실행이 될지 정해주기 때문!)</li>\n</ul>\n</li>\n</ul>\n<h3>느낀점</h3>\n<ul>\n<li>항상 함수형 컴포넌트(hooks)만 쓰니<br>\nclass형 컴포넌트의 <code class=\"language-text\">componentDidMount</code>나 <code class=\"language-text\">componentDidUpdate</code>를 볼때마다<br>\n무슨 의미를 뜻하는 지 몰랐는데 이 정리 잘되어 있는 블로그를 보면서 많은 정리를 할 수 있었던 것 같다!<br>\n그리고 존재만 알았던 <code class=\"language-text\">useMemo</code>와 <code class=\"language-text\">useCallback</code>의 특징도 알 수 있었던 글이라 좋았다!</li>\n</ul>\n<br/>\n<p><strong>참고 링크</strong></p>\n<ul>\n<li><a href=\"https://juicyjerry.tistory.com/148\" target=\"_blank\" rel=\"nofollow\">리액트 최적화 요약집👍👍 (useCallback, useMemo …)</a></li>\n</ul>","frontmatter":{"title":"[Tech Article] 리액트 최적화 요약집 (useCallback, useMemo ...)","summary":null,"date":"2021.05.04.","categories":["Tech Article"],"options":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMJBf/EABYBAQEBAAAAAAAAAAAAAAAAAAAFBv/aAAwDAQACEAMQAAAB2O58M9Jm22QSU8TWIWB//8QAHBAAAgEFAQAAAAAAAAAAAAAAAgYEAAEDBQcQ/9oACAEBAAEFAnd0wJcVN6HpXMK6Go5GuBl1s6E3ANgGiAC8/8QAGxEAAgMAAwAAAAAAAAAAAAAAAgMBBAUQEyP/2gAIAQMBAT8Bx8DM28yIrWoVrV02rF0GMWAgpVlQKMIsMrqYEof2MhbCZ4kIQTZhR8//xAAcEQABBAMBAAAAAAAAAAAAAAACAQMEERITIRD/2gAIAQIBAT8BOVKbn6CYuIbGxuSl0jok2JMFSFRFmphljwC4SWQe/wD/xAAmEAACAgIBAgUFAAAAAAAAAAABAgMEERIFEyEAEBQiIwYxMkFR/9oACAEBAAY/AqFmaha5D1101Fhq9Pqe2F5SfkdckkKqgK37LagZ8BabCpfQObPGWpB6lQD7XrMq9G7CR3kkhb4SQrpk+VFa1oV7vH3DZqxyKzQW5DBLH6eV12NbbOwsBHCkBXUggrbrv9OXW5KTm+HevyaDlEn4+FHp9Rq60s1LMdmNWzLM7rHHsVwc4VBnCgKNmZ2wOw2dyzuf6zEs33JJ8lLKrFG2TYA6t3Gy5/FsEjI79z5f/8QAGRABAQADAQAAAAAAAAAAAAAAAREAIUEQ/9oACAEBAAE/IVO7FIimmkLvUU7Dc5o70g5Op4AVCdALhPGBZ3jh4Uz1UovG8oQ1hoNEBAryvFcVLAypgTPAOAsXz//aAAwDAQACAAMAAAAQDMcA/8QAFhEAAwAAAAAAAAAAAAAAAAAAAREg/9oACAEDAQE/EAiQfp8eSx8Tn//EABYRAQEBAAAAAAAAAAAAAAAAAAERIP/aAAgBAgEBPxBG9Qhwa4NFJlBi/wD/xAAYEAEBAQEBAAAAAAAAAAAAAAABEQAQIf/aAAgBAQABPxD1eBCluIyyPXqrRa943PM8isElBwaaDGUY1PnFQ3+Pe8LEeJKzLZjize8LpeOldqJQ6WbKd//Z"},"images":{"fallback":{"src":"/static/82e255e22d8f11f3dc5ee1a69318a5a1/8938a/background_tech_article.jpg","srcSet":"/static/82e255e22d8f11f3dc5ee1a69318a5a1/936b0/background_tech_article.jpg 90w,\n/static/82e255e22d8f11f3dc5ee1a69318a5a1/55343/background_tech_article.jpg 180w,\n/static/82e255e22d8f11f3dc5ee1a69318a5a1/8938a/background_tech_article.jpg 360w","sizes":"(min-width: 360px) 360px, 100vw"},"sources":[{"srcSet":"/static/82e255e22d8f11f3dc5ee1a69318a5a1/be9e0/background_tech_article.webp 90w,\n/static/82e255e22d8f11f3dc5ee1a69318a5a1/e8c26/background_tech_article.webp 180w,\n/static/82e255e22d8f11f3dc5ee1a69318a5a1/6d50c/background_tech_article.webp 360w","type":"image/webp","sizes":"(min-width: 360px) 360px, 100vw"}]},"width":360,"height":360}},"publicURL":"/static/82e255e22d8f11f3dc5ee1a69318a5a1/background_tech_article.jpg"}}}}]}},"pageContext":{"slug":"/2021/2021-05-04-[기술문서_정리]_리액트_최적화_요약집_(useCallback,_useMemo)/"}},
    "staticQueryHashes": []}
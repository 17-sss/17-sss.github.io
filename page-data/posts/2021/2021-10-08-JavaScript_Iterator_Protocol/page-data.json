{"componentChunkName":"component---src-pages-custom-post-tsx","path":"/posts/2021/2021-10-08-JavaScript_Iterator_Protocol/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"1a5792ca-c5f5-5835-9fa0-9f48286846d9","fields":{"slug":"/2021/2021-10-08-JavaScript_Iterator_Protocol/"},"html":"<div align=\"center\">\n<p>최근에 본 면접에서 <code class=\"language-text\">Iterator Protocol</code>이라는 키워드가 나왔다.<br>\n어디서 들어본 것 같지만 (역시 아니지..)<br>\n정말 완전 처음 듣는 단어라 “모르겠습니다” 라고 답했다.. 😭<br>\n<img src=\"https://user-images.githubusercontent.com/33610315/136487038-4ac55776-7854-4e56-82fd-e3a6bd753c70.png\" width=\"300\"><br/>\n알아야 할 건 끝이 없는 것 같다!<br>\n아쉬운 김에 정리!!</p>\n</div>\n<br/>\n<h2>🤔 Iteration protocols이 뭐야?</h2>\n<p><code class=\"language-text\">Iterator Protocol</code>을 알아보기 전에 <code class=\"language-text\">Iteration protocols</code>을 알아야한다!<br>\n<code class=\"language-text\">Iteration protocols</code>은 ES6에서 추가되었다.<br>\n데이터 컬렉션을 순회하기 위한 프로토콜 (<em>미리 약속된 규칙</em>)이다.</p>\n<br/>\n<p><strong>이터레이션 프로토콜을 준수한 객체는..</strong><br>\n<code class=\"language-text\">for..of</code> 문으로 순회할 수 있고 <em>Spread</em> 문법의 피연산자가 될 수 있다.</p>\n<br/>\n<p><strong>이터레이션 프로토콜의 종류는?</strong><br>\n이터러블 프로토콜(<em>iterable protocol</em>)과 이터레이터 프로토콜(<em>iterator protocol</em>)이 있다.</p>\n<br/>\n<div align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/33610315/136503080-24929823-0a8f-4e7f-bb1d-91ac84e320fd.png\" width=\"500\"><br>\n</div>\n<p><strong>이터레이션 프로토콜을 따르는 객체는?</strong></p>\n<p><code class=\"language-text\">for..of</code>, <code class=\"language-text\">spread operator</code>, <code class=\"language-text\">yield*</code>, <code class=\"language-text\">destructuring assignment</code> 과 같은 문법들을 사용할 수 있다.</p>\n<br/>\n<h3>[1] 이터러블</h3>\n<p>이터러블 프로토콜을 따르는 객체는 <strong>이터러블</strong> 객체라 한다.<br>\n이터러블은 <code class=\"language-text\">Symbol.iterator</code> 메소드를 구현하거나, <u>프로토타입 체인에 의해 상속</u>된 객체를 말한다.<br>\n이터러블은 for..of 문에서 순회할 수 있으며 Spread 문법의 대상으로 사용할 수 있다!</p>\n<h4>1) 배열</h4>\n<p>배열은 <code class=\"language-text\">Symbol.iterator</code> 을 <u>소유</u>한다. 따라서 배열은 이터러블 프로토콜을 <span style=\"color: blue\">준수한 이터러블</span>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 배열은 Symbol.iterator 메소드를 소유한다.</span>\n<span class=\"token comment\">// 따라서 배열은 이터러블 프로토콜을 준수한 이터러블이다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Symbol<span class=\"token punctuation\">.</span>iterator <span class=\"token keyword\">in</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// 이터러블 프로토콜을 준수한 배열은 for..of 문에서 순환 가능하다.</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> item <span class=\"token keyword\">of</span> array<span class=\"token punctuation\">)</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>2) 일반 객체</h4>\n<p>일반 객체는 <code class=\"language-text\">Symbol.iterator</code>을 <u>소유하지 않는다</u>. 따라서 일반객체는 이터러블 프로토콜을 <span style=\"color: red\">준수한 이터러블이 아니다.</span></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 일반 객체는 Symbol.iterator 메소드를 소유하지 않는다.</span>\n<span class=\"token comment\">// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Symbol<span class=\"token punctuation\">.</span>iterator <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n\n<span class=\"token comment\">// 이터러블이 아닌 일반 객체는 for...of 문에서 순회할 수 없다.</span>\n<span class=\"token comment\">// TypeError: obj is not iterable</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> p <span class=\"token keyword\">of</span> obj<span class=\"token punctuation\">)</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>일반 객체는 이터레이션 프로토콜을 준수하지 않는다. 그러므로 이터러블이 아니다 (<code class=\"language-text\">Symbol.iterator</code>이 없다)</li>\n<li>일반 객체는 <code class=\"language-text\">for...of</code>문에서도 순회할 수 없으며 <u>Spread 문법의 대상으로도 사용할 수 없다.</u></li>\n<li>일반 객체도 이터러블 프로토콜을 <u>준수하게 만들면</u> 이터러블이 된다. (커스텀 이터러블)</li>\n</ul>\n<br/>\n<h3>[2] 이터레이터</h3>\n<p><strong>이터레이터 프로토콜</strong>은 <code class=\"language-text\">next</code> 메소드를 가지고 있어야하며,<br>\n<code class=\"language-text\">next</code> 메소드를 호출하면 이터러블을 순회하며 <code class=\"language-text\">value</code>, <code class=\"language-text\">done</code> 프로퍼티를 갖는<br>\n이터레이터 리절트 객체를 반환하는 것이며, 이 규약을 준수한 객체가 이터레이터이다.</p>\n<p>이터러블 프로토콜을 <span style=\"color: blue\">준수한 이터러블</span>은 <code class=\"language-text\">Symbol.iterator</code> 메소드를 소유한다.<br>\n이 메소드를 호출하면 이터레이터를 반환한다.<br>\n이터레이터 프로토콜을 <u>준수한 이터레이터</u>는 <code class=\"language-text\">next</code> 메소드를 갖는다!</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 배열은 이터러블 프로토콜을 준수한 이터러블!</span>\n<span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Symbol.iterator 메소드는 이터레이터를 반환한다.</span>\n<span class=\"token keyword\">const</span> iterator <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 1)이터레이터 프로토콜을 준수한 이터레이터는 next 메소드를 갖는다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'next'</span> <span class=\"token keyword\">in</span> iterator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// 2) 이터레이터의 next 메소드를 호출하면 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환.</span>\n<span class=\"token keyword\">let</span> iteratorResult <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iteratorResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: 1, done: false}</span>\n\n<span class=\"token comment\">// 3) next 메소드를 호출할 때 마다 이터러블을 순회하며 이터레이터 리절트 객체를 반환.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: 2, done: false}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: 3, done: false}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: undefined, done: true}</span></code></pre></div>\n<ol>\n<li>이터레이터의 <code class=\"language-text\">next</code> 메소드를 호출하면 <code class=\"language-text\">value</code>, <code class=\"language-text\">done</code> 프로퍼티를 갖는 <strong>이터레이터 리절트 객체를 반환.</strong></li>\n<li>이터레이터의 <code class=\"language-text\">next</code> 메소드는 이터러블의 각 요소를 순회하기 위한 포인터의 역할<br>\n<code class=\"language-text\">next</code> 메소드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 이터레이터 리절트 객체를 반환.</li>\n<li>이터레이터의 next 메소드가 반환하는 이터레이터 리절트 객체의 프로퍼티들\n<ul>\n<li><code class=\"language-text\">value</code> 프로퍼티는 현재 순회 중인 이터러블의 값을 반환</li>\n<li><code class=\"language-text\">done</code> 프로퍼티는 이터러블의 순회 완료 여부를 반환.</li>\n</ul>\n</li>\n</ol>\n<br/>\n<h3>[3] 빌트인 이터러블</h3>\n<p><span id=\"iterlist\" style=\"font-weight: bold; color: brown\">ES6에서 제공하는 빌트인 이터러블 목록</span></p>\n<ul>\n<li><code class=\"language-text\">Array</code>, <code class=\"language-text\">String</code>, <code class=\"language-text\">Map</code>, <code class=\"language-text\">Set</code>, <code class=\"language-text\">Arguments</code></li>\n<li>TypedArray\n<ul>\n<li><code class=\"language-text\">Int8Array</code>, <code class=\"language-text\">Int16Array</code>, <code class=\"language-text\">Int32Array</code></li>\n<li><code class=\"language-text\">Uint8Array</code>, <code class=\"language-text\">Uint16Array</code>, <code class=\"language-text\">Uint32Array</code></li>\n<li><code class=\"language-text\">Uint8ClampedArray</code></li>\n<li><code class=\"language-text\">Float32Array</code>, <code class=\"language-text\">Float64Array</code></li>\n</ul>\n</li>\n<li>DOM data structure\n<ul>\n<li><code class=\"language-text\">NodeList</code>, <code class=\"language-text\">HTMLCollection</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>String을 활용한 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 문자열은 이터러블이다.</span>\n<span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이터러블은 Symbol.iterator 메소드를 소유한다.</span>\n<span class=\"token comment\">// Symbol.iterator 메소드는 이터레이터를 반환한다.</span>\nstrIter <span class=\"token operator\">=</span> str<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이터레이터는 next 메소드를 소유한다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strIter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: \"h\", done: false}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strIter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: \"i\", done: false}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strIter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: undefined, done: true}</span>\n\n<span class=\"token comment\">// 이터러블은 for ... of 문으로 순회 가능하다.</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> char <span class=\"token keyword\">of</span> str<span class=\"token punctuation\">)</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Arguments을 활용한 예시</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 이터러블은 Symbol.iterator 메소드를 소유한다.</span>\n  <span class=\"token comment\">// Symbol.iterator 메소드는 이터레이터를 반환한다.</span>\n  iter <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 이터레이터는 next 메소드를 소유한다.</span>\n  <span class=\"token comment\">// next 메소드는 이터레이터 리절트 객체를 반환한다.</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: 1, done: false}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: 2, done: false}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>iter<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {value: undefined, done: true}</span>\n\n  <span class=\"token comment\">// 이터러블은 for...of 문으로 순회 가능하다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> arg <span class=\"token keyword\">of</span> arguments<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br/>\n<h3>[4] 이터레이션 프로토콜의 필요성</h3>\n<p>데이터 소비자( <em>Data consumer</em> )인 for…of 문, spread 문법은<br>\n다양한 데이터 소스(<a href=\"#iterlist\">ES6에서 제공하는 빌트인 이터러블 목록</a>)를 사용한다.</p>\n<p>데이터 소스는 모두 이터레이션 프로토콜을 준수하는 이터러블.<br>\n즉, 이터러블은 데이터 공급자( <em>Data provider</em> )의 역할을 한다.</p>\n<p>만약 다양한 데이터 소스가 각자 순회 방식을 갖는다면<br>\n데이터 소비자는 다양한 데이터 소스의 순회 방식을 모두 지원해야 한다. 이는 효율적이지 않다!!<br>\n하지만 다양한 데이터 소스가 이터레이션 프로토콜을 준수하도록 규정하면<br>\n데이터 소비자는 이터레이션 프로토콜만을 지원하도록 구현하면 된다.</p>\n<p>즉, <u>이터레이션 프로토콜</u>은 다양한 데이터 소스가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로<br>\n다양한 데이터 소스를 사용할 수 있도록 <strong>데이터 소비자와 데이터 소스를 연결하는 인터페이스 역할을 한다!</strong></p>\n<br>\n<div align=\"center\">\n\t<img src=\"https://user-images.githubusercontent.com/33610315/136513648-d59f22b0-0fe3-49d9-a9e0-a2fe00615001.png\" width=\"600\">  \n</div>\n<p>이터러블을 지원하는 데이터 소비자는 내부에서 <code class=\"language-text\">Symbol.iterator</code>메소드를 호출해 이터레이터를 생성 →<br>\n이터레이터의 <code class=\"language-text\">next</code>메소드를 호출하여 이터러블을 순회 →<br>\n<code class=\"language-text\">next</code> 메소드가 반환한 이터레이터 리절트 객체의 <code class=\"language-text\">value</code> 프로퍼티 값을 취득한다.</p>\n<hr>\n<p>어떻게보면.. 진짜 지나가다가 봤을수도 있다.<br>\n근데 익숙하지 않은 단어가 들려오니 전혀 모르겠더라<br>\n그래도 이렇게 찾아보니까 성장 +1 한거 같다!<br>\n다음엔 이터레이션 프로토콜에 뒤이은 글을 조금 더 써보도록 하자.</p>\n<hr>\n<h3>참고자료</h3>\n<ul>\n<li><a href=\"https://poiemaweb.com/es6-iteration-for-of\" target=\"_blank\" rel=\"nofollow\">poiemaweb - 이터레이션과 for…of 문</a> ⭐️</li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols\" target=\"_blank\" rel=\"nofollow\">mozilla : Iteration protocols</a></li>\n<li><a href=\"https://equal-blog.tistory.com/entry/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9CIteration-Protocol\" target=\"_blank\" rel=\"nofollow\">[Javascript] 이터레이션 프로토콜(Iteration Protocol)</a></li>\n</ul>","frontmatter":{"title":"[JavaScript] 대체 Iterator Protocol이란 뭘까?","summary":null,"date":"2021.10.08.","categories":["JavaScript"],"options":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEElEQVQ4y+2Sy2sTURTGTyYzxjzakGeJSe6ZxLYLd7qwiIgPECkIIrhy7UZwKy610oUUQkqLoqIBreBCsCCiFPEPqFatCOIjM2meY5IaqGTa5nnq7Ygvpori0su3uPfAj/N951xYybC/FvyH/x28rHJt9PyDzvU0W82wZpbpCtfv4cYCl3GnqqxnWO11lMrYLqFhAUzdtvKozUf27bIdHXZ8es86RRw/7+mPSUG/9cgh+8vHW9p51FUzWFdYp4DZp+EelxBHsVPEu6kAAPQFrDu32wDgxHEXaagrprDK2gXMzUU8bqE/JpKGZ071AkDqop8o/mAqqM1Hmjlu8Fewu5d3Jg2vJXwAsG1QujXpXylgd1HW0xtkrqdZO/8FHoiJ9TQPcuywA9ZPHMV7N4L0wcy2rrBGljVzmHnC4cGt0tLbaKuEjao8fT1wcO9mAHA5hWczISoh/DTnbhmLzyO0KJffRN09wkBc0hVWeRWdexiiRoza8dMnef7EOQ/V5G9wXWFUxstjPofdkhzxTIx6AWDPkK2VZ0M7NkmSJTninbndt383bz416afqd7CuMNJwOhVwOixGPNEKd64GqCZfuuB1OXlREHh9+IB96R1bXfgx87LCqILqbPjKmHdi1PviUai7/pmoKquz4VTSlzjruX8zWFdZM2+2Kl3ho6aPMtXkTol/IyPR1yJVZGM6n1e1BivmpYf2D1IYAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/db7933e6a7f7acaf99a33f39b286974b/34104/background_js.png","srcSet":"/static/db7933e6a7f7acaf99a33f39b286974b/5ce94/background_js.png 256w,\n/static/db7933e6a7f7acaf99a33f39b286974b/8a20a/background_js.png 512w,\n/static/db7933e6a7f7acaf99a33f39b286974b/34104/background_js.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/db7933e6a7f7acaf99a33f39b286974b/99d55/background_js.webp 256w,\n/static/db7933e6a7f7acaf99a33f39b286974b/3591c/background_js.webp 512w,\n/static/db7933e6a7f7acaf99a33f39b286974b/e306d/background_js.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}},"publicURL":"/static/db7933e6a7f7acaf99a33f39b286974b/background_js.png"}}}}]}},"pageContext":{"slug":"/2021/2021-10-08-JavaScript_Iterator_Protocol/"}},"staticQueryHashes":["1642645631","2183628444","3096950251","3590156278","3949884163","77750267","884297919"]}